"use strict"
const http = require('http');
const uuid = require('node-uuid');
//const url = require('url');
//const WebSocket = require('ws');
//const querystring = require('querystring');
const rpcApiHelper = require('http-rpc-helper');

// I'm attempting to make this one module function as the code for both server
//  agent, session agent and client agent.  I'm struggling a bit and confusing
//  myself a lot.

class seamlesssession2 extends rpcApiHelper {
  constructor(serverBaseUri) {
    // Call rpcApiHelper's constructor
    super(serverBaseUri);

    // Define some variables with default values
    this.clientUriBase = '';
    this.sessionUriBase = '';
    this.sessionHostUriBase = '';

    this.mode = seamlesssession2.MODE_CLIENT;
    this.apiDefinationGenerated = null;
  }

  get apiDefination() {
    if (this.apiDefinationGenerated == null) {
      this.apiDefinationGenerated = 'in progress'
      this.apiDefinationGenerated = this.apiDefinationGeneratorTest(this);
    }

    return this.apiDefinationGenerated;
  }

  get version() {
    return seamlesssession2.VERSION;
  }
}

var sessionHostSession = class {
  constructor(api, mode) {
    this._uuid = '';
    this._initid = '';
    this._clientUriBase = '';
    this._sessionUriBase = '';
    this._sessionUsername = '';
    this._sessionClientName = '';
    this._mode = mode;
    this._xpraClipboard = '';
  }

  get uuid() {
    if (this._uuid == '') {
      this._uuid = uuid.v4();
    }
    return this._uuid;
  }

  set uuid(value) {
    this._uuid = value;
  }

  get initid() {
    return this._initid;
  }

  set initid(value) {
    this._initid = value;
  }

  get sessionUsername() {
    return this._sessionUsername;
  }

  set sessionUsername(value) {
    this._sessionUsername = value;
  }

  get sessionUriBase() {
    return this._sessionUriBase;
  }

  set sessionUriBase(value) {
    this._sessionUriBase = value;
  }

  get clientUriBase() {
    return this._clientUriBase;
  }

  set clientUriBase(value) {
    this._clientUriBase = value;
  }

  // Forward a request made by a client to the session agent
  forwardClientRequest() {

  }

  // Forward a request made by the session agent to the client
  forwardSessionRequest() {

  }
}

//this.client = class {
class client extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_CLIENT;

    //this.xfreerdp = require('xfreerdp');
    //console.log("constructor: ", this.api);
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

/**
  Causes a URL to be opened in the client's local browser
  @private
  @param {string} uri - The URI to open
  @returns {string} - "OK" on success.
*/
  openUri(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: Open the passed URI with the local default browser
  }

  notification(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: interface with the local notification API and cause a notification
  }

  registerClient(sessionuuid) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_REGISTERCLIENT?
  }

  start () {
    //TODO: start the Xpra clipboard listener
    //TODO: Run xfreerdp
    //TODO: registerClient
  }

  getType() {
    return this.constructor;
  }
}

class session extends seamlesssession2 {
  constructor(serverBaseUri) {
    super(serverBaseUri);

    this.mode = seamlesssession2.MODE_SESSION;

    let sessionHost = new sessionhost();
    this.sessionhostApi = sessionHost.apiDefination;

    this.httpAgent = new http.Agent({ keepAlive: true });
    this.httpAgentDefaultOptions = {
      'method': 'GET',
      'port': 3002,
      'hostname': 'localhost',
      'headers': {
        'Content-Type' : 'application/json'
      },
    };
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_OPENURI?
  }

  launchapp() {
    //TODO: Launch a local app
  }

  /**
    Registers a new session on the session host
  */
  registerSession() {
    //console.log('registerSession', this)
    this.wrap(this.sessionhostApi, seamlesssession2.URI_REGISTERSESSION, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
      }
    });
  }

  getType() {
    return this.constructor;
  }
}

class sessionhost extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_SESSIONHOST;

    this.sessionHostSessions = {};
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

/**
  Causes a URL to be opened in the client's local browser (forwareded to client)
  @param {string} sessionUuid - The sessio/client shared UUID
  @param {string} uri - The URI to open
  @param {boolean} newWindow - Whether or not this URI should be opened in a new window
  @returns {string} - "OK" on success.
*/
  openUri(sessionUuid, uri, newWindow) {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  /**
    Causes a popup notification to be opened in the client's local desktop (forwareded to client)
    @param {string} sessionUuid - The sessio/client shared UUID
    @returns {string} - "OK" on success.
  */
  notification() {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

/**
  Causes a new application to be launched within the client's server session
  (forwarded to session)
  @param {string} sessionUuid - The sessio/client shared UUID
  @returns {string} - "OK" on success.
*/
  launchapp() {
    //TODO: Forward action to session
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  /**
    Creates a new session that is manages by this session host.  This sets up
    the parameters for how messages are passed between client and session.
    @param {string} sessionUuid - The session/client shared UUID
    @param {string} sessionInitId - An initial basic identifier to match client and session
    @param {string} sessionUsername - Login username of the session
    @param {string} sessionUriBase - Uri base for callbacks to the session agent
    @param {string} clientUriBase - Uri base for callbacks to the client agent
    @returns {string} - "OK" on success.
  */
  registerSession(sessionUuid, sessionInitId, sessionUsername, sessionUriBase, clientUriBase) {
    console.log("The real sessionhost registerSession!", sessionUsername);
    let thisSession = null;

    console.log(this.sessionHostSessions);
    if ((sessionUuid === undefined) || (sessionUuid == null)) {
      //TODO: Search for sessions with a matching sessionInitId
      for (let sessionuuid in this.sessionHostSessions) {
        console.log(sessionuuid);
        let session = this.sessionHostSessions[sessionuuid];
        if ((session._initid == sessionInitId) && (session._sessionUsername == sessionUsername)) {
          thisSession = this.sessionHostSessions[session._uuid];
        }
      }

      if (thisSession == null) {
        console.log('need a new sessionuuid');
        thisSession = new sessionHostSession();
        thisSession._initid = sessionInitId;
        sessionUuid = thisSession.uuid;
        this.sessionHostSessions[thisSession.uuid] = thisSession;
      }
    }
    else if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
    }
    else {
      thisSession = new sessionHostSession();
      sessionUuid = thisSession.uuid;
      this.sessionHostSessions[thisSession.uuid] = thisSession;
    }

    if ((sessionInitId !== undefined) && (sessionInitId != null)) {
      thisSession.initid = sessionInitId;
    }

    if ((sessionUsername !== undefined) && (sessionUsername != null)) {
      thisSession.sessionUsername = sessionUsername;
    }

    if ((sessionUriBase !== undefined) && (sessionUriBase != null)) {
      thisSession.sessionUriBase = sessionUriBase;
    }

    if ((clientUriBase !== undefined) && (clientUriBase != null)) {
      thisSession.clientUriBase = clientUriBase;
    }

    console.log(this.sessionHostSessions);

    return {'sessionuuid': thisSession.uuid};
    //TODO: return a jwt?
  }

  registerClient(sessionUuid, clientUriBase, sessionUsername) {
    let thisSession = null;
    if (sessionHostSessions[sessionUuid]) {
      thisSession = sessionHostSessions[sessionUuid];

      //TODO: return a jwt?
    }
    else {
      return seamlesssession2.ERR_NOSUCHSESSION;
    }
  }

  validateSession(sessionUuid) {
    //TODO: This isn't exactly secure.  jwt?
    if (sessionHostSessions[sessionUuid]) {
      return sessionHostSessions[sessionUuid];
    }
    return false;
  }

  getType() {
    return this.constructor;
  }
}

// We define some (not actual) constants.  We define them here so they're
//  available to the calling module before an instance is created with "new".
//  For example, this way the calling module can do this:
//   var seamlesssession2 = require('seamlesssession2');
//   var SeamlessSession2 = new seamlesssession2(seamlesssession2.MODE_CLIENT);
//  If they were defined only within the seamlesssession2 function above,
//  "seamlesssession2.MODE_CLIENT" would be undefined on line 2 of the above.
seamlesssession2.VERSION = "1.0.0";
seamlesssession2.NAME = "seamlesssession2";
seamlesssession2.URI_VERSION = "version";
seamlesssession2.URI_OPENURI = "open-uri";
seamlesssession2.URI_NOTIFICATION = "notitfication";
seamlesssession2.URI_REGISTERSESSION = "registersession";
seamlesssession2.URI_REGISTERCLIENT = "registerclient";
seamlesssession2.URI_LAUNCHAPP = "launchapp"
seamlesssession2.MODE_CLIENT = 1;
seamlesssession2.MODE_SESSION = 2;
seamlesssession2.MODE_SESSIONHOST = 4;
seamlesssession2.METHOD_GET = 'GET';
seamlesssession2.METHOD_PUT = 'PUT';
seamlesssession2.METHOD_POST = 'POST';
seamlesssession2.ERR_NOTIMPLEMENTED = {
  'error': {
    'num': 1,
    'message': 'Not implemented'
  }
};
seamlesssession2.ERR_NOSUCHSESSION = {
  'error': {
    'num': 2,
    'message': 'No such session'
  }
};

module.exports = seamlesssession2;
module.exports.client = client;
module.exports.session = session;
module.exports.sessionhost = sessionhost;
