"use strict"
const http = require('http');
const uuid = require('node-uuid');
const url = require('url');
const WebSocket = require('ws');
const querystring = require('querystring');

// I'm attempting to make this one module function as the code for both server
//  agent, session agent and client agent.  I'm struggling a bit and confusing
//  myself a lot.


var rpcApiHelper = class {
  constructor(serverBaseUri) {
    //super();

    // This is for when we're making requests as a client to a server
    if ((serverBaseUri != undefined) && (serverBaseUri != null)) {
      this.serverBaseUri = serverBaseUri;
      this.ws = null;
      this.httpAgent = null;
    }

    // This is for when we're acting as a server listening for client requests
    this.wss = null;

    // When using WebSocket we need to keep track of which responses relate to
    //  which requests.  We're going to keep a table of objects indexed by a
    //  UUID generated for each request.
    this.wsRequests = {};
  }

  /**
  First crack at a function that can take a class object and dynamically extract
  an apiDefination from the embedded jsDoc
  */
  apiDefinationGeneratorTest(obj) {
    let newProps = {};
    do {
      for (let index of Object.getOwnPropertyNames(obj)) {
        if (obj[index]) {
          if ((typeof obj[index]) == 'function') {
            let jsDoc = ''

            // The constructor function contains all the code for the class,
            //  including the comments between functions which is where the
            //  jsDoc definition for the function lives.
            if (obj['constructor']) {
              let done = false;

              // The first line of this specific function will be the last line
              //  in the constructor we need to look at.  The relevant jsDoc
              //  should be right above.
              let firstLine = obj[index].toString().split(/\n/)[0];

              // We are going to parse every line of the constructor until we
              //  find the first line of the function we're looking for.
              for (let line of obj['constructor'].toString().split(/\n/)) {
                if (!done) {
                  // Start of a new jsDoc segment.  Anything we already have is
                  //  not related to this function.
                  if (line.match(/\/\*\*/)) {
                    jsDoc = line + '\n';
                  }

                  // There should be no lines that start with a "}" within the
                  //  jsDoc definition so if we find one we've meandered out of
                  //  the jsDoc definition.  This makes sure that later
                  //  functions that have no jsDoc defition don't get jsDoc
                  //  definitions from earlier functions (the earlier functions
                  //  will end with "}").
                  else if (line.replace(/^\s*/g, '').match(/^}/)) {
                    jsDoc = '';
                  }

                  // If this line from the constructor matches the first line
                  //  from this function (with leading whitespace removed), we
                  //  have what we came for.  Don't process future lines.
                  else if (line.replace(/^\s*/g, '') == firstLine) {
                    done = true;
                  }

                  // Either this line is part of the jsDoc or it's junk, Either
                  //  way, append it to the jsDoc we're extracting.  If it's
                  //  junk it will be cleared by the start of the next jsDoc
                  //  segment or the end of a function.
                  else {
                    jsDoc += line + '\n';
                  }
                }
              }
            }

            // Now we just tidy up the jsDoc fragment we extracted.  More to do
            //  here.
            if (jsDoc.match(/\/\*\*/)) {
              jsDoc = jsDoc.split(/\/\*\*/)[1];
            }
            else {
              jsDoc = '';
            }
            if (jsDoc.match(/\*\//)) {
              jsDoc = jsDoc.split(/\*\//)[0];
            }

            if (jsDoc.length > 0) {
              jsDoc = jsDoc.replace(/^\s*/mg, '');
              console.log(index);
              console.log(jsDoc);
            }
          }
        }
      }
    } while (obj = Object.getPrototypeOf(obj));
  }

  /**
    Takes a request object and the api definition in 'this' and TODO
    @private
    @param {http.IncomingMessage} req - object created by a 'request' event
    @param {string} functionName - The name of the function called by the client
    @param {function} callback - Callback
    @returns {} The result of the callback function, if provided, or an array of arguments extracted from req
  */
  unwrap(req, functionName, callback) {
    let result = [];

    let apiObject = this._getApiObject(this.apiDefination, functionName);
    //TODO: Handle apiObject = null;

    for (let paramName in apiObject.params) {
      result.push(null);
      //console.log(paramName);
      if (req.query) {
        if (req.query[paramName]) {
          console.log("I know what to do with " + paramName, apiObject.params[paramName][0]);
          result[apiObject.params[paramName][0]] = this.unwrapValue(req.query[paramName], apiObject.params[paramName]);
          //result[paramName] = req.query[paramName];
        }
      }
      if (req.body) {
        if (req.body[paramName]) {
          console.log("I know what to do with " + paramName, apiObject.params[paramName][0]);
          result[apiObject.params[paramName][0]] = this.unwrapValue(req.body[paramName], apiObject.params[paramName]);
          //result[this.params[paramName][0]] = req.body[paramName];
        }
      }
    }
    console.log('unwrap', result);

    if ((callback != null) && (callback != undefined)) {
      return callback.apply(this, result);
    }
    else {
      return result;
    }
  }

  unwrapWs(req) {
    //TODO
    console.log("unwrapWs", req);
    console.log("unwrapWs", url.parse(req.uri));

    this.apiDefinationGeneratorTest(this);

    return "OK";
  }

  _getApiObject(api, functionName) {
    let apiObject = null;
    for (let index in api.methods) {
      if (index == functionName) {
        apiObject = api.methods[index];
      }
    }
    for (let index in api.properties) {
      if (index == functionName) {
        apiObject = api.properties[index];
      }
    }
    return apiObject;
  }

  //var unwrapValue = function (value, param) {
  unwrapValue(value, param) {
    if (param[1] == 'string') {
      return this.unwrapString(value);
    }
    else if (param[1] == 'bool') {
      return this.unwrapBool(value);
    }
  }

  unwrapString(value) {
  //var unwrapString = function(value) {
    return value;
  }

  unwrapBool(value) {
  //var unwrapBool = function(value) {
    return value;
  }

  //wss* functions are for the WebSocket.Server
  wssOnError(err) {
    console.log("wssOnError", err);
  }

  wssOnConnection(ws) {
    console.log("wssOnConnection");
  }

  wssOnMessage(message, ws) {
    console.log("wssOnMessage", message);
    try {
      let parsedMessage = JSON.parse(message);
      if (parsedMessage.get) {
        try {
          let reply = this.unwrapWs(parsedMessage.get);
          ws.send(JSON.stringify(reply));
        }
        catch (err) {
          console.error("rpcApiHelper.wssOnMessage error: unwrapWs call failed: ", err);
        }
      }
      else if (parsedMessage.response) {
        //TODO
      }
      else {
        console.error("rpcApiHelper.wssOnMessage error: I don't know how to action this message: ", message);
      }
    }
    catch (err) {
      console.error("rpcApiHelper.wssOnMessage error: I don't know how to action this message because it doesn't appear to be valid JSON: ", message);
    }
  }

  //ws* functions are for the WebSocket client
  wsOnMessage(message) {
    console.log("rpcApiHelper.ws: WebSocket message", message);
  }

  wsOnError(err) {
    console.error("rpcApiHelper.ws: WebSocket error", err);
    this.ws = null;
  }

  wsInit(callback) {
    if ((this.ws == null) || (this.ws == undefined)) {
      this.ws = WebSocket(this.serverBaseUri)
      this.ws.on('open', (function open() {
        callback.apply(this);
      }).bind(this));

      this.ws.on('message', (function incoming(message) {
        this.wsOnMessage.apply(this, [message]);
      }).bind(this));

      this.ws.on('close', (function incoming(code, reason) {
        console.log("rpcApiHelper.ws: WebSocket closed", code, reason);
        this.ws = null;
      }).bind(this));

      this.ws.on('error', (function incoming(err) {
        this.wsOnError.apply(this, [err]);
      }).bind(this));
    }
    else {
      callback.apply(this);
    }
  }

  wrap(api, functionName, method, reqArguments, callback) {
    if (url.parse(this.serverBaseUri).protocol.match(/^http/i)) {
      return this.wrapHttp(api, functionName, method, reqArguments, callback)
    }
    else if (url.parse(this.serverBaseUri).protocol.match(/^ws/i)) {
      return this.wrapWs(api, functionName, method, reqArguments, callback);
    }
    else {
      console.error("rpcApiHelper.wrap: Don't know how to handle protocol " + url.parse(this.serverBaseUri).protocol);
    }
  }

  wrapWs(api, functionName, method, reqArguments, callback) {
    let requestData = {};
    let apiObject = this._getApiObject(api, functionName);
    let context = {
      uuid: uuid.v4(),
      callback: callback
    }

    this.wsRequests[context.uuid] = context;

    for (let index in apiObject.params) {
      //console.log(index, apiObject.params[index][0]);
      requestData[index] = reqArguments[apiObject.params[index][0]];
    }

    let message = {
      'get': {
        'uri': '/' + functionName + '?' + querystring.stringify(requestData),
        'headers': {
          'Content-Type' : 'application/json',
          'Request-Id': context.uuid
        }
      }
    }

    this.wsInit((function init(err) {
      if (err) {
        //TODO
        console.log('rpcApiHelper.wrapWs.ws.open error', err);
        return
      }
      this.ws.send(JSON.stringify(message), function ack(err) {
        if (err) {
          console.log('rpcApiHelper.wrapWs.ws.send error', err);
        }
      });
    }).bind(this));
    //console.log('rpcApiHelper.wrapWs.ws', this.ws);

  }

  wrapHttp(api, functionName, method, reqArguments, callback) {
  //var wrap = function(functionName, method, reqArguments, callback) {
    let options = JSON.parse(JSON.stringify(this.httpAgentDefaultOptions));
    let responseData = '';
    let requestData = {};
    options.agent = this.httpAgent;
    options.method = method;
    options.path = '/api/' + seamlesssession2.NAME + '/' + seamlesssession2.VERSION + '/' + functionName;

    //console.log('wrap', arguments);
    //console.log('wrap', this);
    //console.log('wrap', api);

    let apiObject = this._getApiObject(api, functionName);
    //TODO: Handle apiObject = null;
    //console.log('wrap apiObject:', apiObject);

    for (let index in apiObject.params) {
      //console.log(index, apiObject.params[index][0]);
      requestData[index] = reqArguments[apiObject.params[index][0]];
    }
    console.log(requestData);

    let thisRequest = http.request(options, function(res) {
      //console.log(res);
      res.on('data', function(chunk) {
        //console.log("chunk:", chunk);
        responseData += chunk;
      });
      res.on('error', function(err) {
        callback(err, undefined);
      });
      res.on('end', function() {
        let parsedData = '';

        try {
          parsedData = JSON.parse(responseData);
        }
        catch(err) {
          callback(err, undefined);
        }

        callback(undefined, parsedData);
        //console.log('end', responseData);
      });
    });

    if (method == seamlesssession2.METHOD_PUT) {
      thisRequest.end(JSON.stringify(requestData));
    }
  }
}

class seamlesssession2 extends rpcApiHelper {
  constructor(serverBaseUri) {
    // Call rpcApiHelper's constructor
    super(serverBaseUri);

    // Define some variables with default values
    this.clientUriBase = '';
    this.sessionUriBase = '';
    this.sessionHostUriBase = '';

    this.mode = seamlesssession2.MODE_CLIENT;
  }

  get apiDefination() {
    let description = 'REST API for communication between client, session and session host agents';
    //console.log('apiDefination', this);

    if (this.mode == seamlesssession2.MODE_CLIENT) {
      description += ' (client mode)';
    }
    else if (this.mode == seamlesssession2.MODE_SESSIONHOST) {
      description += ' (sessionhost mode)';
    }
    else {
      description += ' (session mode)';
    }

    let returnObject =
      {
        'version': seamlesssession2.VERSION,
        'name': seamlesssession2.NAME,
        'description': description,
        'wss': this.wss,
        'wssEvents': {
          'error': [this, this.wssError],
          'connection': [this, this.wssOnConnection],
          'message': [this, this.wssOnMessage],
        },
        'properties': {
          'version': {
            'uri': seamlesssession2.URI_VERSION,
            'getter': (function(req, res) {
              let replyObject = {'version': this.ActionObject.version.apply(this.ActionObject)};
              res.send(replyObject);
            }).bind(this),
            'description': 'Get the current version of this API'
          }
        },
        'methods': {}
      };

    if (this.mode == seamlesssession2.MODE_CLIENT) {
      returnObject['methods']['openuri'] = {
        'uri': seamlesssession2.URI_OPENURI,
        'action': function(req, res) {
          thisClient.openUri.apply(thisClient, [req, res]);
        },
        'description': 'Open a URI in a browser on the client\'s PC',
        'params': {
          'uri': [0, 'string', 'The URI to open on the client\'s PC'],
          'newWindow': [1, 'bool', 'Force the URI to be opened in a new window.  Default: false.']
        }
      };
      returnObject['methods']['notification'] = {
        'uri': seamlesssession2.URI_NOTIFICATION,
        'action': function(req, res) {
          thisClient.notification.apply(thisClient, [req, res]);
        },
        'description': 'Display a notification on the client\'s PC',
        'params': {
          'text': [0, 'string', 'The text body of the notification'],
          'title': [1, 'string', 'The text title of the notification.  Not supported by all client notification daemons'],
          'icon': [2, 'string', 'The name of an icon to use'],
          'sound': [3, 'bool', 'Play a notification sound on the client\'s PC.  Default: false.']
        }
      };
    }

    if (this.mode == seamlesssession2.MODE_SESSIONHOST) {
      returnObject['methods']['registersession'] = {
        'uri': seamlesssession2.URI_REGISTERSESSION,
        'context': this,
        'action': function(req, res) {
          // Use rpcApiHelper.unwrap to extract the GET/PUT parameters passed by
          //  the remote agent and pass the result to
          //  sessionhost.registerSession.
          let returnValue = this.context.registerSession.apply(this.context, this.context.unwrap(req, seamlesssession2.URI_REGISTERSESSION));
          res.send(returnValue);
        },
        'description': 'Register a new session in the session broker.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'sessioninitid': [1, 'string', 'The unique UUID that identifies this session.'],
          'sessionusername': [2, 'string', 'The unique UUID that identifies this session.'],
          'sessionuri': [3, 'string', 'The URI for connecting to the session\'s agent']
        }
      }
      returnObject['methods']['registerclient'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          console.log(req);
          res.send(seamlesssession2.ERR_NOTIMPLEMENTED);
          //TODO: thisClient.registerClient();
        },
        'description': 'Register a new client in the session broker.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
      returnObject['methods']['launchapp'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          //TODO: thisClient.registerClient();
        },
        'description': 'Launch a new application in the remote session.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
    }
    if (this.mode == seamlesssession2.MODE_SESSION) {
      returnObject['methods']['launchapp'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          //TODO: thisClient.registerClient();
        },
        'description': 'Launch a new application in the remote session.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
    }
    return returnObject;
  }
}

var sessionHostSession = class {
  constructor(api, mode) {
    this._uuid = '';
    this._initid = '';
    this._clientUriBase = '';
    this._sessionUriBase = '';
    this._sessionUsername = '';
    this._sessionClientName = '';
    this._mode = mode;
    this._xpraClipboard = '';
  }

  get uuid() {
    if (this._uuid == '') {
      this._uuid = uuid.v4();
    }
    return this._uuid;
  }

  set uuid(value) {
    this._uuid = value;
  }

  get initid() {
    return this._initid;
  }

  set initid(value) {
    this._initid = value;
  }

  get sessionUsername() {
    return this._sessionUsername;
  }

  set sessionUsername(value) {
    this._sessionUsername = value;
  }

  // Forward a request made by a client to the session agent
  forwardClientRequest() {

  }

  // Forward a request made by the session agent to the client
  forwardSessionRequest() {

  }
}

//this.client = class {
class client extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_CLIENT;

    //this.xfreerdp = require('xfreerdp');
    //console.log("constructor: ", this.api);
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: Open the passed URI with the local default browser
  }

  notification(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: interface with the local notification API and cause a notification
  }

  registerClient(sessionuuid) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_REGISTERCLIENT?
  }

  start () {
    //TODO: start the Xpra clipboard listener
    //TODO: Run xfreerdp
    //TODO: registerClient
  }

  getType() {
    return this.constructor;
  }
}

class session extends seamlesssession2 {
  constructor(serverBaseUri) {
    super(serverBaseUri);

    this.mode = seamlesssession2.MODE_SESSION;

    let sessionHost = new sessionhost();
    this.sessionhostApi = sessionHost.apiDefination;

    this.httpAgent = new http.Agent({ keepAlive: true });
    this.httpAgentDefaultOptions = {
      'method': 'GET',
      'port': 3002,
      'hostname': 'localhost',
      'headers': {
        'Content-Type' : 'application/json'
      },
    };

    //this.ws = new WebSocket('ws://127.0.0.1:3002/');

    //this.ws.on('open', (function open() {
    //  this.ws.send('message from session agent!');
    //}).bind(this));

    //this.ws.on('message', (function incoming(message) {
    //  //console.log('ws.onMessage: received:', message);
    //  //console.log(this.ws);
    //}).bind(this));

    //this.clientUriBase = "https://127.0.0.1:3000/";
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_OPENURI?
  }

  launchapp() {
    //TODO: Launch a local app
  }

  registerSession() {
    //console.log('registerSession', this)
    this.wrap(this.sessionhostApi, seamlesssession2.URI_REGISTERSESSION, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
      }
    });
  }

  getType() {
    return this.constructor;
  }
}

class sessionhost extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_SESSIONHOST;

    this.sessionHostSessions = {};
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(sessionUuid, uri, newWindow) {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  notification() {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  launchapp() {
    //TODO: Forward action to session
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  registerSession(sessionUuid, sessionInitId, sessionUsername, sessionUriBase) {
    console.log("The real sessionhost registerSession!", sessionUsername);
    let thisSession = null;

    console.log(this.sessionHostSessions);
    if ((sessionUuid === undefined) || (sessionUuid == null)) {
      //TODO: Search for sessions with a matching sessionInitId
      for (let sessionuuid in this.sessionHostSessions) {
        console.log(sessionuuid);
        let session = this.sessionHostSessions[sessionuuid];
        if ((session._initid == sessionInitId) && (session._sessionUsername == sessionUsername)) {
          thisSession = this.sessionHostSessions[session._uuid];
        }
      }

      if (thisSession == null) {
        console.log('need a new sessionuuid');
        thisSession = new sessionHostSession();
        sessionUuid = thisSession.uuid;
        this.sessionHostSessions[thisSession.uuid] = thisSession;
      }
    }
    else if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
    }
    else {
      thisSession = new sessionHostSession();
      sessionUuid = thisSession.uuid;
      this.sessionHostSessions[thisSession.uuid] = thisSession;
    }

    if ((sessionInitId !== undefined) && (sessionInitId != null)) {
      thisSession.initid = sessionInitId;
    }

    if ((sessionUsername !== undefined) && (sessionUsername != null)) {
      thisSession.sessionUsername = sessionUsername;
    }

    console.log(this.sessionHostSessions);

    return {'sessionuuid': thisSession.uuid};
    //TODO: return a jwt?
  }

  registerClient(sessionUuid, clientUriBase, sessionUsername) {
    let thisSession = null;
    if (sessionHostSessions[sessionUuid]) {
      thisSession = sessionHostSessions[sessionUuid];

      //TODO: return a jwt?
    }
    else {
      return seamlesssession2.ERR_NOSUCHSESSION;
    }
  }

  validateSession(sessionUuid) {
    //TODO: This isn't exactly secure.  jwt?
    if (sessionHostSessions[sessionUuid]) {
      return sessionHostSessions[sessionUuid];
    }
    return false;
  }

  getType() {
    return this.constructor;
  }
}

// We define some (not actual) constants.  We define them here so they're
//  available to the calling module before an instance is created with "new".
//  For example, this way the calling module can do this:
//   var seamlesssession2 = require('seamlesssession2');
//   var SeamlessSession2 = new seamlesssession2(seamlesssession2.MODE_CLIENT);
//  If they were defined only within the seamlesssession2 function above,
//  "seamlesssession2.MODE_CLIENT" would be undefined on line 2 of the above.
seamlesssession2.VERSION = "1.0.0";
seamlesssession2.NAME = "seamlesssession2";
seamlesssession2.URI_VERSION = "version";
seamlesssession2.URI_OPENURI = "open-uri";
seamlesssession2.URI_NOTIFICATION = "notitfication";
seamlesssession2.URI_REGISTERSESSION = "registersession";
seamlesssession2.URI_REGISTERCLIENT = "registerclient";
seamlesssession2.URI_LAUNCHAPP = "launchapp"
seamlesssession2.MODE_CLIENT = 1;
seamlesssession2.MODE_SESSION = 2;
seamlesssession2.MODE_SESSIONHOST = 4;
seamlesssession2.METHOD_GET = 'GET';
seamlesssession2.METHOD_PUT = 'PUT';
seamlesssession2.METHOD_POST = 'POST';
seamlesssession2.ERR_NOTIMPLEMENTED = {
  'error': {
    'num': 1,
    'message': 'Not implemented'
  }
};
seamlesssession2.ERR_NOSUCHSESSION = {
  'error': {
    'num': 2,
    'message': 'No such session'
  }
};

module.exports = seamlesssession2;
module.exports.client = client;
module.exports.session = session;
module.exports.sessionhost = sessionhost;
