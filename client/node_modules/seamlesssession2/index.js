"use strict"
const http = require('http');
var uuid = require('node-uuid');

// I'm attempting to make this one module function as the code for both server
//  agent, session agent and client agent.  I'm struggling a bit and confusing
//  myself a lot.


var rpcApiHelper = class {
  constructor() {
    //super();
  }

  // This function takes a request object and the api definition in 'this' and TODO
  unwrap(req) {
    console.log("unwrap");
    let result = [];

    for (let paramName in this.params) {
      result.push(null);
      //console.log(paramName);
      if (req.query) {
        if (req.query[paramName]) {
          console.log("I know what to do with " + paramName);
          unwrapValue(req.query[paramName], this.params[paramName]);
          result[paramName] = req.query[paramName];
        }
      }
      if (req.body) {
        if (req.body[paramName]) {
          console.log("I know what to do with " + paramName);
          unwrapValue(req.query[paramName], this.params[paramName]);
          result[this.params[paramName][0]] = req.body[paramName];
        }
      }
    }
    return result;
  }

  //var unwrapValue = function (value, param) {
  unwrapValue(value, param) {
    if (param[1] == 'string') {
      return unwrapString(value);
    }
    else if (param[1] == 'bool') {
      return unwrapBool(value);
    }
  }

  unwrapString(value) {
  //var unwrapString = function(value) {
    return value;
  }

  unwrapBool(value) {
  //var unwrapBool = function(value) {
    return value;
  }

  wrap(functionName, method, reqArguments, callback) {
  //var wrap = function(functionName, method, reqArguments, callback) {
    let options = JSON.parse(JSON.stringify(this.httpAgentDefaultOptions));
    let responseData = '';
    options.agent = this.httpAgent;
    options.method = method;
    options.path = '/api/' + seamlesssession2.NAME + '/' + seamlesssession2.VERSION + '/' + functionName;

    //console.log('wrap', arguments);
    console.log('wrap', this);
    console.log('wrap', this.apiDefination);

    //for (let index in reqArguments) {
    //
    //}

    let thisRequest = http.request(options, function(res) {
      //console.log(res);
      res.on('data', function(chunk) {
        //console.log("chunk:", chunk);
        responseData += chunk;
      });
      res.on('error', function(err) {
        callback(err, undefined);
      });
      res.on('end', function() {
        let parsedData = '';

        try {
          parsedData = JSON.parse(responseData);
        }
        catch(err) {
          callback(err, undefined);
        }

        callback(undefined, parsedData);
        //console.log('end', responseData);
      });
    });

    if (method == seamlesssession2.METHOD_PUT) {
      thisRequest.end(JSON.stringify(reqArguments));
    }
  }
}

class seamlesssession2 extends rpcApiHelper {
  constructor() {
    // Call rpcApiHelper's constructor
    super();

    // Define some variables with default values
    this.clientUriBase = '';
    this.sessionUriBase = '';
    this.sessionHostUriBase = '';

    this.mode = seamlesssession2.MODE_CLIENT;
  }

  get apiDefination() {
    let description = 'REST API for communication between client, session and session host agents';
    //console.log('apiDefination', this);

    if (this.mode == seamlesssession2.MODE_CLIENT) {
      description += ' (client mode)';
    }
    else if (this.mode == seamlesssession2.MODE_SESSIONHOST) {
      description += ' (sessionhost mode)';
    }
    else {
      description += ' (session mode)';
    }

    let returnObject =
      {
        'version': seamlesssession2.VERSION,
        'name': seamlesssession2.NAME,
        'description': description,
        'properties': {
          'version': {
            'uri': seamlesssession2.URI_VERSION,
            'getter': (function(req, res) {
              let replyObject = {'version': this.ActionObject.version.apply(this.ActionObject)};
              res.send(replyObject);
            }).bind(this),
            'description': 'Get the current version of this API'
          }
        },
        'methods': {}
      };

    if (this.mode == seamlesssession2.MODE_CLIENT) {
      returnObject['methods']['openuri'] = {
        'uri': seamlesssession2.URI_OPENURI,
        'action': function(req, res) {
          thisClient.openUri.apply(thisClient, [req, res]);
        },
        'description': 'Open a URI in a browser on the client\'s PC',
        'params': {
          'uri': [0, 'string', 'The URI to open on the client\'s PC'],
          'newWindow': [1, 'bool', 'Force the URI to be opened in a new window.  Default: false.']
        }
      };
      returnObject['methods']['notification'] = {
        'uri': seamlesssession2.URI_NOTIFICATION,
        'action': function(req, res) {
          thisClient.notification.apply(thisClient, [req, res]);
        },
        'description': 'Display a notification on the client\'s PC',
        'params': {
          'text': [0, 'string', 'The text body of the notification'],
          'title': [1, 'string', 'The text title of the notification.  Not supported by all client notification daemons'],
          'icon': [2, 'string', 'The name of an icon to use'],
          'sound': [3, 'bool', 'Play a notification sound on the client\'s PC.  Default: false.']
        }
      };
    }

    if (this.mode == seamlesssession2.MODE_SESSIONHOST) {
      returnObject['methods']['registersession'] = {
        'uri': seamlesssession2.URI_REGISTERSESSION,
        'context': this,
        'action': function(req, res) {
          // Use rpcApiHelper.unwrap to extract the GET/PUT parameters passed by
          //  the remote agent and pass the result to
          //  sessionhost.registerSession.
          let returnValue = this.context.registerSession(this.context.unwrap(req));
          res.send(returnValue);
        },
        'description': 'Register a new session in the session broker.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'sessioninitid': [1, 'string', 'The unique UUID that identifies this session.'],
          'sessionusername': [2, 'string', 'The unique UUID that identifies this session.'],
          'sessionuri': [3, 'string', 'The URI for connecting to the session\'s agent']
        }
      }
      returnObject['methods']['registerclient'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          console.log(req);
          res.send(seamlesssession2.ERR_NOTIMPLEMENTED);
          //TODO: thisClient.registerClient();
        },
        'description': 'Register a new client in the session broker.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
      returnObject['methods']['launchapp'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          //TODO: thisClient.registerClient();
        },
        'description': 'Launch a new application in the remote session.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
    }
    if (this.mode == seamlesssession2.MODE_SESSION) {
      returnObject['methods']['launchapp'] = {
        'uri': seamlesssession2.URI_REGISTERCLIENT,
        'action': function(req, res) {
          //TODO: process the request into function params
          //TODO: thisClient.registerClient();
        },
        'description': 'Launch a new application in the remote session.',
        'params': {
          'sessionuuid': [0, 'string', 'The unique UUID that identifies this session.'],
          'clienturi': [1, 'string', 'The URI for connecting to the client\'s agent']
        }
      }
    }
    return returnObject;
  }
}

var sessionHostSession = class {
  constructor(api, mode) {
    this._uuid = '';
    this._initid = '';
    this._clientUriBase = '';
    this._sessionUriBase = '';
    this._sessionUsername = '';
    this._sessionClientName = '';
    this._mode = mode;
    this._xpraClipboard = '';
  }

  get uuid() {
    if (this._uuid == '') {
      this._uuid = uuid.v4();
    }
    return this._uuid;
  }

  set uuid(value) {
    this._uuid = value;
  }

  get initid() {
    return this._initid;
  }

  set initid(value) {
    this._initid = value;
  }

  get sessionUsername() {
    return this._sessionUsername;
  }

  set sessionUsername(value) {
    this._sessionUsername = value;
  }

  // Forward a request made by a client to the session agent
  forwardClientRequest() {

  }

  // Forward a request made by the session agent to the client
  forwardSessionRequest() {

  }
}

//this.client = class {
class client extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_CLIENT;

    //this.xfreerdp = require('xfreerdp');
    //console.log("constructor: ", this.api);
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: Open the passed URI with the local default browser
  }

  notification(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: interface with the local notification API and cause a notification
  }

  registerClient(sessionuuid) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_REGISTERCLIENT?
  }

  start () {
    //TODO: start the Xpra clipboard listener
    //TODO: Run xfreerdp
    //TODO: registerClient
  }

  getType() {
    return this.constructor;
  }
}

class session extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_SESSION;

    this.httpAgent = new http.Agent({ keepAlive: true });
    this.httpAgentDefaultOptions = {
      'method': 'GET',
      'port': 3002,
      'hostname': 'localhost',
      'headers': {
        'Content-Type' : 'application/json'
      },
    };

    this.clientUriBase = "https://127.0.0.1:3000/";
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_OPENURI?
  }

  launchapp() {
    //TODO: Launch a local app
  }

  registerSession() {
    console.log('registerSession', this)
    this.wrap(seamlesssession2.URI_REGISTERSESSION, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
      }
    });
  }

  getType() {
    return this.constructor;
  }
}

class sessionhost extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_SESSIONHOST;

    this.sessionHostSessions = {};
  }

  version() {
    return seamlesssession2.VERSION;
  }

  openUri(sessionUuid, uri, newWindow) {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  notification() {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  launchapp() {
    //TODO: Forward action to session
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  registerSession(sessionUuid, sessionInitId, sessionUsername, sessionUriBase) {
    console.log("The real sessionhost registerSession!", sessionUsername);
    let thisSession = null;

    if ((sessionUuid === undefined) || (sessionUuid == null)) {
      //TODO: Search for sessions with a matching sessionInitId

      console.log('need a new sessionuuid');
      thisSession = new sessionHostSession();
      sessionUuid = thisSession.uuid;
      this.sessionHostSessions[thisSession.uuid] = thisSession;
    }
    else if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
    }
    else {
      thisSession = new sessionHostSession();
      sessionUuid = thisSession.uuid;
      this.sessionHostSessions[thisSession.uuid] = thisSession;
    }

    if ((sessionInitId !== undefined) && (sessionInitId != null)) {
      thisSession.initid = sessionInitId;
    }

    if ((sessionUsername !== undefined) && (sessionUsername != null)) {
      thisSession.sessionUsername = sessionUsername;
    }

    console.log(this.sessionHostSessions);

    return {'sessionuuid': thisSession.uuid};
    //TODO: return a jwt?
  }

  registerClient(sessionUuid, clientUriBase, sessionUsername) {
    let thisSession = null;
    if (sessionHostSessions[sessionUuid]) {
      thisSession = sessionHostSessions[sessionUuid];

      //TODO: return a jwt?
    }
    else {
      return seamlesssession2.ERR_NOSUCHSESSION;
    }
  }

  validateSession(sessionUuid) {
    //TODO: This isn't exactly secure.  jwt?
    if (sessionHostSessions[sessionUuid]) {
      return sessionHostSessions[sessionUuid];
    }
    return false;
  }

  getType() {
    return this.constructor;
  }
}

// We define some (not actual) constants.  We define them here so they're
//  available to the calling module before an instance is created with "new".
//  For example, this way the calling module can do this:
//   var seamlesssession2 = require('seamlesssession2');
//   var SeamlessSession2 = new seamlesssession2(seamlesssession2.MODE_CLIENT);
//  If they were defined only within the seamlesssession2 function above,
//  "seamlesssession2.MODE_CLIENT" would be undefined on line 2 of the above.
seamlesssession2.VERSION = "1.0.0";
seamlesssession2.NAME = "seamlesssession2";
seamlesssession2.URI_VERSION = "version";
seamlesssession2.URI_OPENURI = "open-uri";
seamlesssession2.URI_NOTIFICATION = "notitfication";
seamlesssession2.URI_REGISTERSESSION = "registersession";
seamlesssession2.URI_REGISTERCLIENT = "registerclient";
seamlesssession2.URI_LAUNCHAPP = "launchapp"
seamlesssession2.MODE_CLIENT = 1;
seamlesssession2.MODE_SESSION = 2;
seamlesssession2.MODE_SESSIONHOST = 4;
seamlesssession2.METHOD_GET = 'GET';
seamlesssession2.METHOD_PUT = 'PUT';
seamlesssession2.METHOD_POST = 'POST';
seamlesssession2.ERR_NOTIMPLEMENTED = {
  'error': {
    'num': 1,
    'message': 'Not implemented'
  }
};
seamlesssession2.ERR_NOSUCHSESSION = {
  'error': {
    'num': 2,
    'message': 'No such session'
  }
};

module.exports = seamlesssession2;
module.exports.client = client;
module.exports.session = session;
module.exports.sessionhost = sessionhost;
