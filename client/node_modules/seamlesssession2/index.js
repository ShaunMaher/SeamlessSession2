"use strict"
const http = require('http');
const uuid = require('node-uuid');
//const url = require('url');
//const WebSocket = require('ws');
//const querystring = require('querystring');
const rpcApiHelper = require('http-rpc-helper');

// I'm attempting to make this one module function as the code for both server
//  agent, session agent and client agent.  I'm struggling a bit and confusing
//  myself a lot.

class seamlesssession2 extends rpcApiHelper {
  constructor(serverBaseUri) {
    // Call rpcApiHelper's constructor
    super(serverBaseUri);

    // Define some variables with default values
    this.clientUriBase = '';
    this.sessionUriBase = '';
    this.sessionHostUriBase = '';

    this.mode = seamlesssession2.MODE_CLIENT;
    this.apiDefinationGenerated = null;
  }

  get apiDefination() {
    if (this.apiDefinationGenerated == null) {
      this.apiDefinationGenerated = 'in progress'
      this.apiDefinationGenerated = this.apiDefinationGeneratorTest(this);
    }

    return this.apiDefinationGenerated;
  }

  get version() {
    return seamlesssession2.VERSION;
  }

  wsOnError(err) {
    super.wsOnError.apply(this, [err]);
    console.error("rpcApiHelper.ws: WebSocket error", err);
    this.ws = null;
  }

  wsOnClose(code, reason) {
    super.wsOnClose.apply(this, [code, reason]);
    console.error("seamlesssession2: WebSocket Closed", code, reason);
    this.ws = null;
  }
}

var sessionHostSession = class {
  constructor(api, mode) {
    this._uuid = '';
    this._initid = '';
    this._clientUriBase = '';
    this._sessionUriBase = '';
    this._sessionUsername = '';
    this._sessionClientName = '';
    this._mode = mode;
    this._clientWs = '';
    this._sessionWs = '';
    this._clientLastSeen = 0;
    this._sessionLastSeen = 0;
    this._autoUuid = true;
  }

  get autoUuid() {
    return this._autoUuid;
  }

  set autoUuid(value) {
    this._autoUuid = value;
  }

  get uuid() {
    if ((this._uuid == '') && (this._autoUuid)) {
      this._uuid = uuid.v4();
    }
    return this._uuid;
  }

  set uuid(value) {
    this._uuid = value;
  }

  get initid() {
    return this._initid;
  }

  set initid(value) {
    this._initid = value;
  }

  get sessionUsername() {
    return this._sessionUsername;
  }

  set sessionUsername(value) {
    this._sessionUsername = value;
  }

  get sessionUriBase() {
    return this._sessionUriBase;
  }

  set sessionUriBase(value) {
    this._sessionUriBase = value;
  }

  get clientUriBase() {
    return this._clientUriBase;
  }

  set clientUriBase(value) {
    this._clientUriBase = value;
  }

  // Forward a request made by a client to the session agent
  forwardClientRequest() {

  }

  // Forward a request made by the session agent to the client
  forwardSessionRequest() {

  }
}

//this.client = class {
class client extends seamlesssession2 {
  constructor(serverBaseUri) {
    super(serverBaseUri);

    this.mode = seamlesssession2.MODE_CLIENT;

    let sessionHost = new sessionhost();
    this.sessionhostApi = sessionHost.apiDefination;

    this.session = new sessionHostSession();
    this.session.autoUuid = false;

    this.housekeepingTimer = null;

    this.httpAgent = new http.Agent({ keepAlive: true });
    this.httpAgentDefaultOptions = {
      'method': 'GET',
      'port': 3002,
      'hostname': 'localhost',
      'headers': {
        'Content-Type' : 'application/json'
      },
    };
  }

  housekeeping() {
    //console.log("session housekeeping");
    console.log('housekeeping: ' + this.serverBaseUri);
    if (this.session.uuid == '') {
      // reconnect?
    }
    else {
      // The session should be considered up and running.  Send periodic pings,
      //  etc.
      console.log("ping: " + this.session.uuid);
      this.pingSessionHost.apply(this, [this.session.uuid]);
    }
  }

  listening(server) {
    console.log("session listening " + this.serverBaseUri);
    //this.housekeeping.apply(this);
    this.housekeepingTimer = setInterval((this.housekeeping).bind(this), 500);
  }

  wsOnClose(code, reason) {
    super.wsOnClose.apply(this, [code, reason]);
    console.error("session: WebSocket Closed", code, reason);
    this.session.uuid == '';
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

/**
  Causes a URL to be opened in the client's local browser
  @private
  @param {string} uri - The URI to open
  @returns {string} - "OK" on success.
*/
  openUri(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: Open the passed URI with the local default browser
  }

  notification(req, res) {
    //res.send({'error': 'Not yet implemented'});
    return seamlesssession2.ERR_NOTIMPLEMENTED;

    //TODO: interface with the local notification API and cause a notification
  }

  registerClient() {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_REGISTERCLIENT?
    console.log(this.serverBaseUri);
    this.wrap(this.sessionhostApi, seamlesssession2.URI_REGISTERCLIENT, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
        if (responseData.sessionuuid) {
          console.log("Session created: " + responseData.sessionuuid)
          this.session.uuid = responseData.sessionuuid;
        }
      }
    });
  }

  /**
    Sends a request to the sessionHost to ensure the session is still active and
    to prevent the sessionHost thinking the session is idle
  */
  pingSessionHost() {
    console.log(this.serverBaseUri);
    console.log(arguments);
    this.wrap(this.sessionhostApi, seamlesssession2.URI_PINGSESSIONHOST, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
        if (responseData.result) {
          console.log("Session pinged: " + responseData.result)
          if (responseData.result.match(/ok/i)) {
          }
          else {
            this.session.uuid = '';
          }
          //this.session.uuid = responseData.sessionuuid;
        }
      }
    });
  }

  start () {
    //TODO: Run xfreerdp
    //TODO: registerClient
  }

  getType() {
    return this.constructor;
  }
}

class session extends seamlesssession2 {
  constructor(serverBaseUri) {
    super(serverBaseUri);

    this.mode = seamlesssession2.MODE_SESSION;

    let sessionHost = new sessionhost();
    this.sessionhostApi = sessionHost.apiDefination;

    this.session = new sessionHostSession();
    this.session.autoUuid = false;

    this.housekeepingTimer = null;

    this.httpAgent = new http.Agent({ keepAlive: true });
    this.httpAgentDefaultOptions = {
      'method': 'GET',
      'port': 3002,
      'hostname': 'localhost',
      'headers': {
        'Content-Type' : 'application/json'
      },
    };
  }

  housekeeping() {
    //console.log("session housekeeping");
    console.log('housekeeping: ' + this.serverBaseUri);
    if (this.session.uuid == '') {
      // reconnect?
    }
    else {
      // The session should be considered up and running.  Send periodic pings,
      //  etc.
      console.log("ping: " + this.session.uuid);
      this.pingSessionHost.apply(this, [this.session.uuid]);
    }
  }

  listening(server) {
    console.log("session listening " + this.serverBaseUri);
    //this.housekeeping.apply(this);
    this.housekeepingTimer = setInterval((this.housekeeping).bind(this), 500);
  }

  wsOnClose(code, reason) {
    super.wsOnClose.apply(this, [code, reason]);
    console.error("session: WebSocket Closed", code, reason);
    this.session.uuid == '';
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

  openUri(req, res) {
    //TODO: PUT: http://this.sessionHostUriBase/api/this.api.name/this.api.version/this.api.URI_OPENURI?
  }

  launchapp() {
    //TODO: Launch a local app
  }

  /**
    Registers a new session on the session host
  */
  registerSession() {
    //console.log('registerSession', this)
    console.log(this.serverBaseUri);
    this.wrap(this.sessionhostApi, seamlesssession2.URI_REGISTERSESSION, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
        if (responseData.sessionuuid) {
          console.log("Session created: " + responseData.sessionuuid)
          this.session.uuid = responseData.sessionuuid;
        }
      }
    });
  }

  /**
    Sends a request to the sessionHost to ensure the session is still active and
    to prevent the sessionHost thinking the session is idle
  */
  pingSessionHost() {
    console.log(this.serverBaseUri);
    console.log(arguments);
    this.wrap(this.sessionhostApi, seamlesssession2.URI_PINGSESSIONHOST, seamlesssession2.METHOD_PUT, arguments, function(err, responseData) {
      if (err) {
        console.log("wrap callback error: ", err);
      }
      else {
        console.log("wrap callback: ", responseData);
        if (responseData.result) {
          console.log("Session pinged: " + responseData.result)
          if (responseData.result.match(/ok/i)) {
          }
          else {
            this.session.uuid = '';
          }
          //this.session.uuid = responseData.sessionuuid;
        }
      }
    });
  }

  getType() {
    return this.constructor;
  }
}

class sessionhost extends seamlesssession2 {
  constructor() {
    super();

    this.mode = seamlesssession2.MODE_SESSIONHOST;

    this.sessionHostSessions = {};

    this.housekeepingTimer = null;
  }

  listening(server) {
    console.log("sessionhost listening");

    this.housekeepingTimer = setInterval((this.housekeeping).bind(this), 500);
  }

/**
  Returns the API version that this session host is using
  @returns {version} - A string representing the API version
*/
  get version() {
    return seamlesssession2.VERSION;
  }

/**
  Causes a URL to be opened in the client's local browser (forwareded to client)
  @param {string} sessionUuid - The sessio/client shared UUID
  @param {string} uri - The URI to open
  @param {boolean} newWindow - Whether or not this URI should be opened in a new window
  @returns {string} - "OK" on success.
*/
  openUri(sessionUuid, uri, newWindow) {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  /**
    Causes a popup notification to be opened in the client's local desktop (forwareded to client)
    @param {string} sessionUuid - The sessio/client shared UUID
    @returns {string} - "OK" on success.
  */
  notification() {
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

/**
  Causes a new application to be launched within the client's server session
  (forwarded to session)
  @param {string} sessionUuid - The sessio/client shared UUID
  @returns {string} - "OK" on success.
*/
  launchapp() {
    //TODO: Forward action to session
    return seamlesssession2.ERR_NOTIMPLEMENTED;
  }

  /**
    Creates a new session that is managed by this session host.  This sets up
    the parameters for how messages are passed between client and session.
    @param {string} sessionUuid - The session/client shared UUID
    @param {string} sessionInitId - An initial basic identifier to match client and session
    @param {string} sessionUsername - Login username of the session
    @param {string} sessionUriBase - Uri base for callbacks to the session agent
    @param {string} clientUriBase - Uri base for callbacks to the client agent
    @returns {string} - "OK" on success.
  */
  registerSession(sessionUuid, sessionInitId, sessionUsername, sessionUriBase, clientUriBase) {
    console.log("The real sessionhost registerSession!", sessionUsername);
    let thisSession = null;

    console.log(this.sessionHostSessions);
    if ((sessionUuid === undefined) || (sessionUuid == null)) {
      //TODO: Search for sessions with a matching sessionInitId
      for (let sessionuuid in this.sessionHostSessions) {
        console.log(sessionuuid);
        let session = this.sessionHostSessions[sessionuuid];
        if ((session._initid == sessionInitId) && (session._sessionUsername == sessionUsername)) {
          thisSession = this.sessionHostSessions[session._uuid];
        }
      }

      if (thisSession == null) {
        console.log('need a new sessionuuid');
        thisSession = new sessionHostSession();
        thisSession._initid = sessionInitId;
        sessionUuid = thisSession.uuid;
        this.sessionHostSessions[thisSession.uuid] = thisSession;
      }
    }
    else if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
    }
    else {
      thisSession = new sessionHostSession();
      sessionUuid = thisSession.uuid;
      this.sessionHostSessions[thisSession.uuid] = thisSession;
    }

    thisSession._sessionLastSeen = Date.now();
    if ((sessionInitId !== undefined) && (sessionInitId != null)) {
      thisSession.initid = sessionInitId;
    }

    if ((sessionUsername !== undefined) && (sessionUsername != null)) {
      thisSession.sessionUsername = sessionUsername;
    }

    if ((sessionUriBase !== undefined) && (sessionUriBase != null)) {
      thisSession.sessionUriBase = sessionUriBase;
    }

    if ((clientUriBase !== undefined) && (clientUriBase != null)) {
      thisSession.clientUriBase = clientUriBase;
    }

    console.log(this.sessionHostSessions);

    return {'sessionuuid': thisSession.uuid};
    //TODO: return a jwt?
  }

  /**
    Creates a new session that is managed by this session host.  This sets up
    the parameters for how messages are passed between client and session.
    @param {string} sessionUuid - The session/client shared UUID
    @param {string} sessionInitId - An initial basic identifier to match client and session
    @param {string} sessionUsername - Login username of the session
    @param {string} sessionUriBase - Uri base for callbacks to the session agent
    @param {string} clientUriBase - Uri base for callbacks to the client agent
    @returns {string} - "OK" on success.
  */
  registerClient(sessionUuid, sessionInitId, sessionUsername, sessionUriBase, clientUriBase) {
    console.log("Register client...")
    let thisSession = null;
    if ((sessionUuid === undefined) || (sessionUuid == null)) {
      //TODO: Search for sessions with a matching sessionInitId
      for (let sessionuuid in this.sessionHostSessions) {
        console.log(sessionuuid);
        let session = this.sessionHostSessions[sessionuuid];
        if ((session._initid == sessionInitId) && (session._sessionUsername == sessionUsername)) {
          thisSession = this.sessionHostSessions[session._uuid];
        }
      }

      if (thisSession == null) {
        console.log(seamlesssession2.ERR_NOSUCHSESSION);
        return seamlesssession2.ERR_NOSUCHSESSION
      }
      else {
        return {'sessionuuid': thisSession.uuid};
      }
    }
  }

  /**
    Creates a new session that is manages by this session host.  This sets up
    the parameters for how messages are passed between client and session.
    @param {string} sessionUuid - The session/client shared UUID
    @returns {string} - "OK" on success.
  */
  pingSessionHost(sessionUuid) {
    let thisSession = null;

    if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
      thisSession._sessionLastSeen = Date.now();
      return {'result' : 'OK'};
    }
    else {
      return {'result' : 'Error'};
    }
  }

  /**
    Creates a new session that is manages by this session host.  This sets up
    the parameters for how messages are passed between client and session.
    @param {string} sessionUuid - The session/client shared UUID
    @returns {string} - "OK" on success.
  */
  pingClient(sessionUuid) {
    if (this.sessionHostSessions[sessionUuid]) {
      thisSession = this.sessionHostSessions[sessionUuid];
      thissession._clientLastSeen = Date.now();
      return {'result' : 'OK'};
    }
    else {
      return {'result' : 'Error'};
    }
  }

  validateSession(sessionUuid) {
    //TODO: This isn't exactly secure.  jwt?
    if (sessionHostSessions[sessionUuid]) {
      return sessionHostSessions[sessionUuid];
    }
    return false;
  }

  getType() {
    return this.constructor;
  }

  /**
    Runs the internal tasks that the session host needs to do periodically
    @private
  */
  housekeeping() {
    //console.log("housekeeping");
  }
}

// We define some (not actual) constants.  We define them here so they're
//  available to the calling module before an instance is created with "new".
//  For example, this way the calling module can do this:
//   var seamlesssession2 = require('seamlesssession2');
//   var SeamlessSession2 = new seamlesssession2(seamlesssession2.MODE_CLIENT);
//  If they were defined only within the seamlesssession2 function above,
//  "seamlesssession2.MODE_CLIENT" would be undefined on line 2 of the above.
seamlesssession2.VERSION = "1.0.0";
seamlesssession2.NAME = "seamlesssession2";
seamlesssession2.URI_VERSION = "version";
seamlesssession2.URI_OPENURI = "open-uri";
seamlesssession2.URI_NOTIFICATION = "notitfication";
seamlesssession2.URI_REGISTERSESSION = "registersession";
seamlesssession2.URI_PINGSESSIONHOST = "pingsessionhost";
seamlesssession2.URI_REGISTERCLIENT = "registerclient";
seamlesssession2.URI_LAUNCHAPP = "launchapp"
seamlesssession2.MODE_CLIENT = 1;
seamlesssession2.MODE_SESSION = 2;
seamlesssession2.MODE_SESSIONHOST = 4;
seamlesssession2.METHOD_GET = 'GET';
seamlesssession2.METHOD_PUT = 'PUT';
seamlesssession2.METHOD_POST = 'POST';
seamlesssession2.ERR_NOTIMPLEMENTED = {
  'error': {
    'num': 1,
    'message': 'Not implemented'
  }
};
seamlesssession2.ERR_NOSUCHSESSION = {
  'error': {
    'num': 2,
    'message': 'No such session'
  }
};

module.exports = seamlesssession2;
module.exports.client = client;
module.exports.session = session;
module.exports.sessionhost = sessionhost;
