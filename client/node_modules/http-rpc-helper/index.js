"use strict"
const http = require('http');
const uuid = require('node-uuid');
const url = require('url');
const WebSocket = require('ws');
const querystring = require('querystring');

var rpcApiHelper = class {
  constructor(serverBaseUri) {
    //super();

    // This is for when we're making requests as a client to a server
    if ((serverBaseUri != undefined) && (serverBaseUri != null)) {
      this.serverBaseUri = serverBaseUri;
      this.ws = null;
      this.httpAgent = null;
    }

    // This is for when we're acting as a server listening for client requests
    this.wss = null;

    // When using WebSocket we need to keep track of which responses relate to
    //  which requests.  We're going to keep a table of objects indexed by a
    //  UUID generated for each request.
    this.wsRequests = {};
  }

  /**
  First crack at a function that can take a class object and dynamically extract
  an apiDefination from the embedded jsDoc
  @private
  */
  apiDefinationGeneratorTest(obj) {
    let newProps = {};
    newProps['methods'] = {};
    newProps['properties'] = {};
    newProps['name'] = obj.constructor.name;

    if (obj.version) {
      newProps['version'] = obj.version;
    }

    newProps['events'] = {
      'listening': [this, this.listening],
      'wssError': [this, this.wssError],
      'wssConnection': [this, this.wssOnConnection],
      'wssMessage': [this, this.wssOnMessage],
    };

    do {
      //console.log(obj);
      for (let index of Object.getOwnPropertyNames(obj)) {
        if (obj[index]) {
          if ((typeof obj[index]) == 'function') {
            let jsDoc = ''

            // The constructor function contains all the code for the class,
            //  including the comments between functions which is where the
            //  jsDoc definition for the function lives.
            if (obj['constructor']) {
              let done = false;

              // The first line of this specific function will be the last line
              //  in the constructor we need to look at.  The relevant jsDoc
              //  should be right above.
              let firstLine = obj[index].toString().split(/\n/)[0];

              // We are going to parse every line of the constructor until we
              //  find the first line of the function we're looking for.
              for (let line of obj['constructor'].toString().split(/\n/)) {
                if (!done) {
                  // Start of a new jsDoc segment.  Anything we already have is
                  //  not related to this function.
                  if (line.match(/\/\*\*/)) {
                    jsDoc = line + '\n';
                  }

                  // There should be no lines that start with a "}" within the
                  //  jsDoc definition so if we find one we've meandered out of
                  //  the jsDoc definition.  This makes sure that later
                  //  functions that have no jsDoc defition don't get jsDoc
                  //  definitions from earlier functions (the earlier functions
                  //  will end with "}").
                  else if (line.replace(/^\s*/g, '').match(/^}/)) {
                    jsDoc = '';
                  }

                  // If this line from the constructor matches the first line
                  //  from this function (with leading whitespace removed), we
                  //  have what we came for.  Don't process future lines.
                  else if (line.replace(/^\s*/g, '') == firstLine) {
                    done = true;
                  }

                  // Either this line is part of the jsDoc or it's junk, Either
                  //  way, append it to the jsDoc we're extracting.  If it's
                  //  junk it will be cleared by the start of the next jsDoc
                  //  segment or the end of a function.
                  else {
                    jsDoc += line + '\n';
                  }
                }
              }
            }

            // Now we just tidy up the jsDoc fragment we extracted.  More to do
            //  here.
            if (jsDoc.match(/\/\*\*/)) {
              jsDoc = jsDoc.split(/\/\*\*/)[1];
            }
            else {
              jsDoc = '';
            }
            if (jsDoc.match(/\*\//)) {
              jsDoc = jsDoc.split(/\*\//)[0];
            }

            let functionProperties = obj[index];
            functionProperties['namedArguments'] = {};
            functionProperties['numberedArguments'] = [];
            functionProperties['private'] = false;
            functionProperties['description'] = '';
            functionProperties['returns'] = '';
            if (jsDoc.length > 0) {
              jsDoc = jsDoc.replace(/^\s*/mg, '');
              for (let line of (jsDoc.split(/\n/))) {
                if (line.match(/^\@private/i)) {
                  functionProperties['private'] = true;
                }
                else if (line.match(/^\@param/i)) {
                  let parsedLine = this.parseJsDocLine(line);
                  functionProperties['numberedArguments'].push(parsedLine)
                  functionProperties['namedArguments'][parsedLine[0]] = parsedLine;
                }
                else if (line.match(/^\@return/i)) {
                  functionProperties['returns'] = line;
                }
                else {
                  functionProperties['description'] += line;
                }
              }
              //console.log(index);
              //console.log(jsDoc);
              //console.log(functionProperties);
              newProps['methods'][index] = functionProperties;
              newProps['methods'][index]['uri'] = index;
            }
          }
          else if (typeof obj[index] != 'object') {
            newProps['properties'][index] = {
              'uri': index,
              'getter': 'TODO'
            }
          }
          else {
            //console.log("not a function: ", index, typeof obj[index]);
          }
        }
      }
    } while (obj = Object.getPrototypeOf(obj));

    return newProps;
  }

  /**
    Takes a line of jsDoc formatted text and returns the indervidual parts.
    @private
    @param {string} jsDocLine - A single line of jsDoc text
    @returns {[name, type, description]} - An array of the extracted parts
  */
  parseJsDocLine(jsDocLine) {
    let name = '';
    let description = '';
    let type = '';
    if ((jsDocLine.match(/\{/)) && (jsDocLine.match(/\}/))) {
      name = jsDocLine.split(/\}/)[1];
      type = jsDocLine.split(/\}/)[0];
      type = type.split(/\{/)[1];
    }
    else {
      name = jsDocLine.replace(/^\@\w.*?\W/, '');
    }

    name = name.replace(/^\s*/mg, '');
    if (name.match(/ - /)) {
      description = name.split(/ - /)[1];
      name = name.split(/ - /)[0];
    }

    return [name, type, description];
  }

  /**
    Takes a request object and the api definition in 'this' and TODO
    @private
    @param {http.IncomingMessage} req - object created by a 'request' event
    @param {string} functionName - The name of the function called by the client
    @param {function} callback - Callback
    @returns {} The result of the callback function, if provided, or an array of arguments extracted from req
  */
  unwrap(req, functionName, callback) {
    let result = [];

    let apiObject = this._getApiObject(this.apiDefination, functionName);
    //TODO: Handle apiObject = null;

    //TODO: rewrite for new apiObject schema
    for (let paramName in apiObject.params) {
      result.push(null);
      //console.log(paramName);
      if (req.query) {
        if (req.query[paramName]) {
          console.log("I know what to do with " + paramName, apiObject.params[paramName][0]);
          result[apiObject.params[paramName][0]] = this.unwrapValue(req.query[paramName], apiObject.params[paramName]);
          //result[paramName] = req.query[paramName];
        }
      }
      if (req.body) {
        if (req.body[paramName]) {
          console.log("I know what to do with " + paramName, apiObject.params[paramName][0]);
          result[apiObject.params[paramName][0]] = this.unwrapValue(req.body[paramName], apiObject.params[paramName]);
          //result[this.params[paramName][0]] = req.body[paramName];
        }
      }
    }
    console.log('unwrap', result);

    if ((callback != null) && (callback != undefined)) {
      return callback.apply(this, result);
    }
    else {
      return result;
    }
  }

  unwrapWs(req) {
    //TODO
    //console.log("unwrapWs", req);
    //console.log("unwrapWs", url.parse(req.uri));

    //this.apiDefinationGeneratorTest(this);
    console.log(req);
    let parsedUrl = url.parse(req.uri);
    let requestId = '';
    console.log('headers', req.headers);
    let functionName = parsedUrl.pathname.replace('/', '');
    //console.log('functionName', functionName);

    for (let index in req.headers) {
      if (index.toLowerCase() == 'request-id') {
        requestId = req.headers[index];
      }
    }

    let apiObject = this._getApiObject(this.apiDefination, functionName);
    let requestArguments = querystring.parse(parsedUrl.query);
    let functionArguments = [];
    for (let index in apiObject.numberedArguments) {
      functionArguments[index] = null;
      for (let funcIndex in requestArguments) {
        if (apiObject.numberedArguments[index][0].toLowerCase() == funcIndex.toLowerCase()) {
          //console.log(apiObject.numberedArguments[index][0], funcIndex);
          functionArguments[index] = requestArguments[funcIndex];
        }
      }
    }

    //console.log(apiObject);
    let result = apiObject.apply(this, functionArguments);

    let message = {
      'get': {
        'uri': '/' + functionName + '?' + querystring.stringify(result),
        'headers': {
          'Content-Type' : 'application/json',
          'Response-Id': requestId
        }
      }
    }

    return message;
  }

  _getApiObject(api, functionName) {
    let apiObject = null;
    //console.log(functionName, api.methods);
    for (let index in api.methods) {
      if (index.toLowerCase() == functionName.toLowerCase()) {
        apiObject = api.methods[index];
      }
    }
    for (let index in api.properties) {
      if (index == functionName) {
        apiObject = api.properties[index];
      }
    }
    return apiObject;
  }

  //var unwrapValue = function (value, param) {
  unwrapValue(value, param) {
    if (param[1] == 'string') {
      return this.unwrapString(value);
    }
    else if (param[1] == 'bool') {
      return this.unwrapBool(value);
    }
  }

  unwrapString(value) {
  //var unwrapString = function(value) {
    return value;
  }

  unwrapBool(value) {
  //var unwrapBool = function(value) {
    return value;
  }

  listening(server) {
    console.log("http-rpc-helper listening");
  }

  //wss* functions are for the WebSocket.Server
  wssOnError(err) {
    console.log("wssOnError", err);
  }

  wssOnConnection(ws) {
    console.log("wssOnConnection");
  }

  wssOnMessage(message, ws) {
    console.log("wssOnMessage", message);
    try {
      let parsedMessage = JSON.parse(message);
      if (parsedMessage.get) {
        try {
          let reply = this.unwrapWs(parsedMessage.get);
          ws.send(JSON.stringify(reply));
        }
        catch (err) {
          console.error("rpcApiHelper.wssOnMessage error: unwrapWs call failed: ", err);
        }
      }
      else if (parsedMessage.response) {
        //TODO
      }
      else {
        console.error("rpcApiHelper.wssOnMessage error: I don't know how to action this message: ", message);
      }
    }
    catch (err) {
      console.error("rpcApiHelper.wssOnMessage error: I don't know how to action this message because it doesn't appear to be valid JSON: ", message);
    }
  }

  //ws* functions are for the WebSocket client
  wsOnMessage(message) {
    console.log("rpcApiHelper.ws: WebSocket message", message);

    let parsedMessage = JSON.parse(message);
    let parsedUrl = null;
    let request = null;
    if (parsedMessage.get) {
      if (parsedMessage.get.uri) {
        parsedUrl = url.parse(parsedMessage.get.uri);
      }
      if (parsedMessage.get.headers) {
        for (let index in parsedMessage.get.headers) {
          if (index.toLowerCase() == 'response-id') {
            if (this.wsRequests[parsedMessage.get.headers[index]]) {
              request = this.wsRequests[parsedMessage.get.headers[index]];
              console.log("Response to request: ", request);
              request.callback.apply(this, [null, querystring.parse(parsedUrl.query)])
            }
          }
        }
      }
    }
  }

  wsOnError(err) {
    console.error("rpcApiHelper.ws: WebSocket error", err);
    this.ws = null;
  }

  wsOnClose(code, reason) {
    console.error("rpcApiHelper.ws: WebSocket Closed", code, reason);
    this.ws = null;
  }

  wsInit(callback) {
    if ((this.ws == null) || (this.ws == undefined)) {
      // I don't see what the following line was intended to do.
      //this.serverBaseUri = 'http://127.0.0.1:3002/api/sessionhost/1.0.0/'
      let serverBaseUri = this.serverBaseUri.replace(/ws:\/\//, 'http://');

      console.log('rpcApiHelper.ws: serverBaseUri: ' + serverBaseUri);
      this.ws = WebSocket(this.serverBaseUri)
      this.ws.on('open', (function open() {
        callback.apply(this);
      }).bind(this));

      this.ws.on('message', (function incoming(message) {
        this.wsOnMessage.apply(this, [message]);
      }).bind(this));

      this.ws.on('close', (function close(code, reason) {
        console.log("rpcApiHelper.ws: WebSocket closed", code, reason);
        this.wsOnClose.apply(this, [code, reason]);
      }).bind(this));

      this.ws.on('error', (function incoming(err) {
        this.wsOnError.apply(this, [err]);
      }).bind(this));
    }
    else {
      callback.apply(this);
    }
  }

  wrap(api, functionName, method, reqArguments, callback) {
    if (url.parse(this.serverBaseUri).protocol.match(/^http/i)) {
      return this.wrapHttp(api, functionName, method, reqArguments, callback)
    }
    else if (url.parse(this.serverBaseUri).protocol.match(/^ws/i)) {
      return this.wrapWs(api, functionName, method, reqArguments, callback);
    }
    else {
      console.error("rpcApiHelper.wrap: Don't know how to handle protocol " + url.parse(this.serverBaseUri).protocol);
    }
  }

  wrapWs(api, functionName, method, reqArguments, callback) {
    let requestData = {};
    let apiObject = this._getApiObject(api, functionName);
    let context = {
      uuid: uuid.v4(),
      callback: callback
    }

    if (apiObject == null) {
      //TODO: Do I have a method to pass back an error?
      console.log("wrapWs: unknown function: '" + functionName + "'");
      callback.apply(this, [null]);
    }

    this.wsRequests[context.uuid] = context;

    let numericArgs = false;
    for (let index in reqArguments) {
      if (Number.isInteger(parseInt(index))) {
        numericArgs = true;
      }
    }

    if (numericArgs) {
      for (let index in apiObject.numberedArguments) {
        //console.log(apiObject.numberedArguments[index][0]);
        if (reqArguments[index]) {
          requestData[apiObject.numberedArguments[index][0]] = reqArguments[index];
        }
      }
    }
    else {
      for (let index in apiObject.namedArguments) {
        //console.log(index);
        if (reqArguments[index]) {
          requestData[index] = reqArguments[index];
        }
      }
    }


    //for (let index in apiObject.params) {
    //  //console.log(index, apiObject.params[index][0]);
    //  requestData[index] = reqArguments[apiObject.params[index][0]];
    //}

    let message = {
      'get': {
        'uri': '/' + functionName + '?' + querystring.stringify(requestData),
        'headers': {
          'Content-Type' : 'application/json',
          'Request-Id': context.uuid
        }
      }
    }

    this.wsInit((function opened(err) {
      if (err) {
        //TODO
        console.log('rpcApiHelper.wrapWs.ws.open error', err);
        return
      }
      this.ws.send(JSON.stringify(message), function ack(err) {
        if (err) {
          console.log('rpcApiHelper.wrapWs.ws.send error', err);
        }
        else {
          console.log("ws request sent");
        }
      });
    }).bind(this), (function closed(code, reason) {
      console.log('rpcApiHelper.wrapWs: Web socket closed.')
    }).bind(this));
    //console.log('rpcApiHelper.wrapWs.ws', this.ws);
  }

  wrapHttp(api, functionName, method, reqArguments, callback) {
  //var wrap = function(functionName, method, reqArguments, callback) {
    let options = JSON.parse(JSON.stringify(this.httpAgentDefaultOptions));
    let responseData = '';
    let requestData = {};
    options.agent = this.httpAgent;
    options.method = method;
    options.path = '/api/' + seamlesssession2.NAME + '/' + seamlesssession2.VERSION + '/' + functionName;

    //console.log('wrap', arguments);
    //console.log('wrap', this);
    //console.log('wrap', api);

    let apiObject = this._getApiObject(api, functionName);
    //TODO: Handle apiObject = null;
    //console.log('wrap apiObject:', apiObject);

    for (let index in apiObject.params) {
      //console.log(index, apiObject.params[index][0]);
      requestData[index] = reqArguments[apiObject.params[index][0]];
    }
    console.log(requestData);

    let thisRequest = http.request(options, function(res) {
      //console.log(res);
      res.on('data', function(chunk) {
        //console.log("chunk:", chunk);
        responseData += chunk;
      });
      res.on('error', function(err) {
        callback(err, undefined);
      });
      res.on('end', function() {
        let parsedData = '';

        try {
          parsedData = JSON.parse(responseData);
        }
        catch(err) {
          callback(err, undefined);
        }

        callback(undefined, parsedData);
        //console.log('end', responseData);
      });
    });

    if (method == seamlesssession2.METHOD_PUT) {
      thisRequest.end(JSON.stringify(requestData));
    }
  }
}

module.exports = rpcApiHelper;
